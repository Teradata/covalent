{"version":3,"file":"inert.esm-a76031cb.js","sources":["../../../../node_modules/blocking-elements/dist/blocking-elements.js","../../../../node_modules/wicg-inert/dist/inert.esm.js"],"sourcesContent":["/**\n * @license\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n(() => {\n    var _a, _b, _c;\n    /* Symbols for private properties */\n    const _blockingElements = Symbol();\n    const _alreadyInertElements = Symbol();\n    const _topElParents = Symbol();\n    const _siblingsToRestore = Symbol();\n    const _parentMO = Symbol();\n    /* Symbols for private static methods */\n    const _topChanged = Symbol();\n    const _swapInertedSibling = Symbol();\n    const _inertSiblings = Symbol();\n    const _restoreInertedSiblings = Symbol();\n    const _getParents = Symbol();\n    const _getDistributedChildren = Symbol();\n    const _isInertable = Symbol();\n    const _handleMutations = Symbol();\n    class BlockingElementsImpl {\n        constructor() {\n            /**\n             * The blocking elements.\n             */\n            this[_a] = [];\n            /**\n             * Used to keep track of the parents of the top element, from the element\n             * itself up to body. When top changes, the old top might have been removed\n             * from the document, so we need to memoize the inerted parents' siblings\n             * in order to restore their inerteness when top changes.\n             */\n            this[_b] = [];\n            /**\n             * Elements that are already inert before the first blocking element is\n             * pushed.\n             */\n            this[_c] = new Set();\n        }\n        destructor() {\n            // Restore original inertness.\n            this[_restoreInertedSiblings](this[_topElParents]);\n            // Note we don't want to make these properties nullable on the class,\n            // since then we'd need non-null casts in many places. Calling a method on\n            // a BlockingElements instance after calling destructor will result in an\n            // exception.\n            const nullable = this;\n            nullable[_blockingElements] = null;\n            nullable[_topElParents] = null;\n            nullable[_alreadyInertElements] = null;\n        }\n        get top() {\n            const elems = this[_blockingElements];\n            return elems[elems.length - 1] || null;\n        }\n        push(element) {\n            if (!element || element === this.top) {\n                return;\n            }\n            // Remove it from the stack, we'll bring it to the top.\n            this.remove(element);\n            this[_topChanged](element);\n            this[_blockingElements].push(element);\n        }\n        remove(element) {\n            const i = this[_blockingElements].indexOf(element);\n            if (i === -1) {\n                return false;\n            }\n            this[_blockingElements].splice(i, 1);\n            // Top changed only if the removed element was the top element.\n            if (i === this[_blockingElements].length) {\n                this[_topChanged](this.top);\n            }\n            return true;\n        }\n        pop() {\n            const top = this.top;\n            top && this.remove(top);\n            return top;\n        }\n        has(element) {\n            return this[_blockingElements].indexOf(element) !== -1;\n        }\n        /**\n         * Sets `inert` to all document elements except the new top element, its\n         * parents, and its distributed content.\n         */\n        [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {\n            const toKeepInert = this[_alreadyInertElements];\n            const oldParents = this[_topElParents];\n            // No new top, reset old top if any.\n            if (!newTop) {\n                this[_restoreInertedSiblings](oldParents);\n                toKeepInert.clear();\n                this[_topElParents] = [];\n                return;\n            }\n            const newParents = this[_getParents](newTop);\n            // New top is not contained in the main document!\n            if (newParents[newParents.length - 1].parentNode !== document.body) {\n                throw Error('Non-connected element cannot be a blocking element');\n            }\n            // Cast here because we know we'll call _inertSiblings on newParents\n            // below.\n            this[_topElParents] = newParents;\n            const toSkip = this[_getDistributedChildren](newTop);\n            // No previous top element.\n            if (!oldParents.length) {\n                this[_inertSiblings](newParents, toSkip, toKeepInert);\n                return;\n            }\n            let i = oldParents.length - 1;\n            let j = newParents.length - 1;\n            // Find common parent. Index 0 is the element itself (so stop before it).\n            while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {\n                i--;\n                j--;\n            }\n            // If up the parents tree there are 2 elements that are siblings, swap\n            // the inerted sibling.\n            if (oldParents[i] !== newParents[j]) {\n                this[_swapInertedSibling](oldParents[i], newParents[j]);\n            }\n            // Restore old parents siblings inertness.\n            i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));\n            // Make new parents siblings inert.\n            j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);\n        }\n        /**\n         * Swaps inertness between two sibling elements.\n         * Sets the property `inert` over the attribute since the inert spec\n         * doesn't specify if it should be reflected.\n         * https://html.spec.whatwg.org/multipage/interaction.html#inert\n         */\n        [_swapInertedSibling](oldInert, newInert) {\n            const siblingsToRestore = oldInert[_siblingsToRestore];\n            // oldInert is not contained in siblings to restore, so we have to check\n            // if it's inertable and if already inert.\n            if (this[_isInertable](oldInert) && !oldInert.inert) {\n                oldInert.inert = true;\n                siblingsToRestore.add(oldInert);\n            }\n            // If newInert was already between the siblings to restore, it means it is\n            // inertable and must be restored.\n            if (siblingsToRestore.has(newInert)) {\n                newInert.inert = false;\n                siblingsToRestore.delete(newInert);\n            }\n            newInert[_parentMO] = oldInert[_parentMO];\n            newInert[_siblingsToRestore] = siblingsToRestore;\n            oldInert[_parentMO] = undefined;\n            oldInert[_siblingsToRestore] = undefined;\n        }\n        /**\n         * Restores original inertness to the siblings of the elements.\n         * Sets the property `inert` over the attribute since the inert spec\n         * doesn't specify if it should be reflected.\n         * https://html.spec.whatwg.org/multipage/interaction.html#inert\n         */\n        [_restoreInertedSiblings](elements) {\n            for (const element of elements) {\n                const mo = element[_parentMO];\n                mo.disconnect();\n                element[_parentMO] = undefined;\n                const siblings = element[_siblingsToRestore];\n                for (const sibling of siblings) {\n                    sibling.inert = false;\n                }\n                element[_siblingsToRestore] = undefined;\n            }\n        }\n        /**\n         * Inerts the siblings of the elements except the elements to skip. Stores\n         * the inerted siblings into the element's symbol `_siblingsToRestore`.\n         * Pass `toKeepInert` to collect the already inert elements.\n         * Sets the property `inert` over the attribute since the inert spec\n         * doesn't specify if it should be reflected.\n         * https://html.spec.whatwg.org/multipage/interaction.html#inert\n         */\n        [_inertSiblings](elements, toSkip, toKeepInert) {\n            for (const element of elements) {\n                // Assume element is not a Document, so it must have a parentNode.\n                const parent = element.parentNode;\n                const children = parent.children;\n                const inertedSiblings = new Set();\n                for (let j = 0; j < children.length; j++) {\n                    const sibling = children[j];\n                    // Skip the input element, if not inertable or to be skipped.\n                    if (sibling === element || !this[_isInertable](sibling) ||\n                        (toSkip && toSkip.has(sibling))) {\n                        continue;\n                    }\n                    // Should be collected since already inerted.\n                    if (toKeepInert && sibling.inert) {\n                        toKeepInert.add(sibling);\n                    }\n                    else {\n                        sibling.inert = true;\n                        inertedSiblings.add(sibling);\n                    }\n                }\n                // Store the siblings that were inerted.\n                element[_siblingsToRestore] = inertedSiblings;\n                // Observe only immediate children mutations on the parent.\n                const mo = new MutationObserver(this[_handleMutations].bind(this));\n                element[_parentMO] = mo;\n                let parentToObserve = parent;\n                // If we're using the ShadyDOM polyfill, then our parent could be a\n                // shady root, which is an object that acts like a ShadowRoot, but isn't\n                // actually a node in the real DOM. Observe the real DOM parent instead.\n                const maybeShadyRoot = parentToObserve;\n                if (maybeShadyRoot.__shady && maybeShadyRoot.host) {\n                    parentToObserve = maybeShadyRoot.host;\n                }\n                mo.observe(parentToObserve, {\n                    childList: true,\n                });\n            }\n        }\n        /**\n         * Handles newly added/removed nodes by toggling their inertness.\n         * It also checks if the current top Blocking Element has been removed,\n         * notifying and removing it.\n         */\n        [_handleMutations](mutations) {\n            const parents = this[_topElParents];\n            const toKeepInert = this[_alreadyInertElements];\n            for (const mutation of mutations) {\n                // If the target is a shadowRoot, get its host as we skip shadowRoots when\n                // computing _topElParents.\n                const target = mutation.target.host || mutation.target;\n                const idx = target === document.body ?\n                    parents.length :\n                    parents.indexOf(target);\n                const inertedChild = parents[idx - 1];\n                const inertedSiblings = inertedChild[_siblingsToRestore];\n                // To restore.\n                for (let i = 0; i < mutation.removedNodes.length; i++) {\n                    const sibling = mutation.removedNodes[i];\n                    if (sibling === inertedChild) {\n                        console.info('Detected removal of the top Blocking Element.');\n                        this.pop();\n                        return;\n                    }\n                    if (inertedSiblings.has(sibling)) {\n                        sibling.inert = false;\n                        inertedSiblings.delete(sibling);\n                    }\n                }\n                // To inert.\n                for (let i = 0; i < mutation.addedNodes.length; i++) {\n                    const sibling = mutation.addedNodes[i];\n                    if (!this[_isInertable](sibling)) {\n                        continue;\n                    }\n                    if (toKeepInert && sibling.inert) {\n                        toKeepInert.add(sibling);\n                    }\n                    else {\n                        sibling.inert = true;\n                        inertedSiblings.add(sibling);\n                    }\n                }\n            }\n        }\n        /**\n         * Returns if the element is inertable.\n         */\n        [_isInertable](element) {\n            return false === /^(style|template|script)$/.test(element.localName);\n        }\n        /**\n         * Returns the list of newParents of an element, starting from element\n         * (included) up to `document.body` (excluded).\n         */\n        [_getParents](element) {\n            const parents = [];\n            let current = element;\n            // Stop to body.\n            while (current && current !== document.body) {\n                // Skip shadow roots.\n                if (current.nodeType === Node.ELEMENT_NODE) {\n                    parents.push(current);\n                }\n                // ShadowDom v1\n                if (current.assignedSlot) {\n                    // Collect slots from deepest slot to top.\n                    while (current = current.assignedSlot) {\n                        parents.push(current);\n                    }\n                    // Continue the search on the top slot.\n                    current = parents.pop();\n                    continue;\n                }\n                current = current.parentNode ||\n                    current.host;\n            }\n            return parents;\n        }\n        /**\n         * Returns the distributed children of the element's shadow root.\n         * Returns null if the element doesn't have a shadow root.\n         */\n        [_getDistributedChildren](element) {\n            const shadowRoot = element.shadowRoot;\n            if (!shadowRoot) {\n                return null;\n            }\n            const result = new Set();\n            let i;\n            let j;\n            let nodes;\n            const slots = shadowRoot.querySelectorAll('slot');\n            if (slots.length && slots[0].assignedNodes) {\n                for (i = 0; i < slots.length; i++) {\n                    nodes = slots[i].assignedNodes({\n                        flatten: true,\n                    });\n                    for (j = 0; j < nodes.length; j++) {\n                        if (nodes[j].nodeType === Node.ELEMENT_NODE) {\n                            result.add(nodes[j]);\n                        }\n                    }\n                }\n                // No need to search for <content>.\n            }\n            return result;\n        }\n    }\n    document.$blockingElements =\n        new BlockingElementsImpl();\n})();\n//# sourceMappingURL=blocking-elements.js.map","var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * This work is licensed under the W3C Software and Document License\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n */\n\n(function () {\n  // Return early if we're not running inside of the browser.\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  // Convenience function for converting NodeLists.\n  /** @type {typeof Array.prototype.slice} */\n  var slice = Array.prototype.slice;\n\n  /**\n   * IE has a non-standard name for \"matches\".\n   * @type {typeof Element.prototype.matches}\n   */\n  var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n  /** @type {string} */\n  var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\n\n  /**\n   * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n   * attribute.\n   *\n   * Its main functions are:\n   *\n   * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n   *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n   *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n   *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n   *   instance exists for each focusable node which has at least one inert root as an ancestor.\n   *\n   * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n   *   attribute is removed from the root node). This is handled in the destructor, which calls the\n   *   `deregister` method on `InertManager` for each managed inert node.\n   */\n\n  var InertRoot = function () {\n    /**\n     * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.\n     * @param {!InertManager} inertManager The global singleton InertManager object.\n     */\n    function InertRoot(rootElement, inertManager) {\n      _classCallCheck(this, InertRoot);\n\n      /** @type {!InertManager} */\n      this._inertManager = inertManager;\n\n      /** @type {!HTMLElement} */\n      this._rootElement = rootElement;\n\n      /**\n       * @type {!Set<!InertNode>}\n       * All managed focusable nodes in this InertRoot's subtree.\n       */\n      this._managedNodes = new Set();\n\n      // Make the subtree hidden from assistive technology\n      if (this._rootElement.hasAttribute('aria-hidden')) {\n        /** @type {?string} */\n        this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n      } else {\n        this._savedAriaHidden = null;\n      }\n      this._rootElement.setAttribute('aria-hidden', 'true');\n\n      // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n      this._makeSubtreeUnfocusable(this._rootElement);\n\n      // Watch for:\n      // - any additions in the subtree: make them unfocusable too\n      // - any removals from the subtree: remove them from this inert root's managed nodes\n      // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n      //   element, make that node a managed node.\n      this._observer = new MutationObserver(this._onMutation.bind(this));\n      this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n     * stored in this object and updates the state of all of the managed nodes.\n     */\n\n\n    _createClass(InertRoot, [{\n      key: 'destructor',\n      value: function destructor() {\n        this._observer.disconnect();\n\n        if (this._rootElement) {\n          if (this._savedAriaHidden !== null) {\n            this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n          } else {\n            this._rootElement.removeAttribute('aria-hidden');\n          }\n        }\n\n        this._managedNodes.forEach(function (inertNode) {\n          this._unmanageNode(inertNode.node);\n        }, this);\n\n        // Note we cast the nulls to the ANY type here because:\n        // 1) We want the class properties to be declared as non-null, or else we\n        //    need even more casts throughout this code. All bets are off if an\n        //    instance has been destroyed and a method is called.\n        // 2) We don't want to cast \"this\", because we want type-aware optimizations\n        //    to know which properties we're setting.\n        this._observer = /** @type {?} */null;\n        this._rootElement = /** @type {?} */null;\n        this._managedNodes = /** @type {?} */null;\n        this._inertManager = /** @type {?} */null;\n      }\n\n      /**\n       * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n       */\n\n    }, {\n      key: '_makeSubtreeUnfocusable',\n\n\n      /**\n       * @param {!Node} startNode\n       */\n      value: function _makeSubtreeUnfocusable(startNode) {\n        var _this2 = this;\n\n        composedTreeWalk(startNode, function (node) {\n          return _this2._visitNode(node);\n        });\n\n        var activeElement = document.activeElement;\n\n        if (!document.body.contains(startNode)) {\n          // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n          var node = startNode;\n          /** @type {!ShadowRoot|undefined} */\n          var root = undefined;\n          while (node) {\n            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n              root = /** @type {!ShadowRoot} */node;\n              break;\n            }\n            node = node.parentNode;\n          }\n          if (root) {\n            activeElement = root.activeElement;\n          }\n        }\n        if (startNode.contains(activeElement)) {\n          activeElement.blur();\n          // In IE11, if an element is already focused, and then set to tabindex=-1\n          // calling blur() will not actually move the focus.\n          // To work around this we call focus() on the body instead.\n          if (activeElement === document.activeElement) {\n            document.body.focus();\n          }\n        }\n      }\n\n      /**\n       * @param {!Node} node\n       */\n\n    }, {\n      key: '_visitNode',\n      value: function _visitNode(node) {\n        if (node.nodeType !== Node.ELEMENT_NODE) {\n          return;\n        }\n        var element = /** @type {!HTMLElement} */node;\n\n        // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n        // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n        if (element !== this._rootElement && element.hasAttribute('inert')) {\n          this._adoptInertRoot(element);\n        }\n\n        if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n          this._manageNode(element);\n        }\n      }\n\n      /**\n       * Register the given node with this InertRoot and with InertManager.\n       * @param {!Node} node\n       */\n\n    }, {\n      key: '_manageNode',\n      value: function _manageNode(node) {\n        var inertNode = this._inertManager.register(node, this);\n        this._managedNodes.add(inertNode);\n      }\n\n      /**\n       * Unregister the given node with this InertRoot and with InertManager.\n       * @param {!Node} node\n       */\n\n    }, {\n      key: '_unmanageNode',\n      value: function _unmanageNode(node) {\n        var inertNode = this._inertManager.deregister(node, this);\n        if (inertNode) {\n          this._managedNodes['delete'](inertNode);\n        }\n      }\n\n      /**\n       * Unregister the entire subtree starting at `startNode`.\n       * @param {!Node} startNode\n       */\n\n    }, {\n      key: '_unmanageSubtree',\n      value: function _unmanageSubtree(startNode) {\n        var _this3 = this;\n\n        composedTreeWalk(startNode, function (node) {\n          return _this3._unmanageNode(node);\n        });\n      }\n\n      /**\n       * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n       * @param {!HTMLElement} node\n       */\n\n    }, {\n      key: '_adoptInertRoot',\n      value: function _adoptInertRoot(node) {\n        var inertSubroot = this._inertManager.getInertRoot(node);\n\n        // During initialisation this inert root may not have been registered yet,\n        // so register it now if need be.\n        if (!inertSubroot) {\n          this._inertManager.setInert(node, true);\n          inertSubroot = this._inertManager.getInertRoot(node);\n        }\n\n        inertSubroot.managedNodes.forEach(function (savedInertNode) {\n          this._manageNode(savedInertNode.node);\n        }, this);\n      }\n\n      /**\n       * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n       * @param {!Array<!MutationRecord>} records\n       * @param {!MutationObserver} self\n       */\n\n    }, {\n      key: '_onMutation',\n      value: function _onMutation(records, self) {\n        records.forEach(function (record) {\n          var target = /** @type {!HTMLElement} */record.target;\n          if (record.type === 'childList') {\n            // Manage added nodes\n            slice.call(record.addedNodes).forEach(function (node) {\n              this._makeSubtreeUnfocusable(node);\n            }, this);\n\n            // Un-manage removed nodes\n            slice.call(record.removedNodes).forEach(function (node) {\n              this._unmanageSubtree(node);\n            }, this);\n          } else if (record.type === 'attributes') {\n            if (record.attributeName === 'tabindex') {\n              // Re-initialise inert node if tabindex changes\n              this._manageNode(target);\n            } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\n              // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n              // already managed nodes from this inert subroot.\n              this._adoptInertRoot(target);\n              var inertSubroot = this._inertManager.getInertRoot(target);\n              this._managedNodes.forEach(function (managedNode) {\n                if (target.contains(managedNode.node)) {\n                  inertSubroot._manageNode(managedNode.node);\n                }\n              });\n            }\n          }\n        }, this);\n      }\n    }, {\n      key: 'managedNodes',\n      get: function get() {\n        return new Set(this._managedNodes);\n      }\n\n      /** @return {boolean} */\n\n    }, {\n      key: 'hasSavedAriaHidden',\n      get: function get() {\n        return this._savedAriaHidden !== null;\n      }\n\n      /** @param {?string} ariaHidden */\n\n    }, {\n      key: 'savedAriaHidden',\n      set: function set(ariaHidden) {\n        this._savedAriaHidden = ariaHidden;\n      }\n\n      /** @return {?string} */\n      ,\n      get: function get() {\n        return this._savedAriaHidden;\n      }\n    }]);\n\n    return InertRoot;\n  }();\n\n  /**\n   * `InertNode` initialises and manages a single inert node.\n   * A node is inert if it is a descendant of one or more inert root elements.\n   *\n   * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n   * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n   * is intrinsically focusable or not.\n   *\n   * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n   * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n   * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n   * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n   * or removes the `tabindex` attribute if the element is intrinsically focusable.\n   */\n\n\n  var InertNode = function () {\n    /**\n     * @param {!Node} node A focusable element to be made inert.\n     * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n     */\n    function InertNode(node, inertRoot) {\n      _classCallCheck(this, InertNode);\n\n      /** @type {!Node} */\n      this._node = node;\n\n      /** @type {boolean} */\n      this._overrodeFocusMethod = false;\n\n      /**\n       * @type {!Set<!InertRoot>} The set of descendant inert roots.\n       *    If and only if this set becomes empty, this node is no longer inert.\n       */\n      this._inertRoots = new Set([inertRoot]);\n\n      /** @type {?number} */\n      this._savedTabIndex = null;\n\n      /** @type {boolean} */\n      this._destroyed = false;\n\n      // Save any prior tabindex info and make this node untabbable\n      this.ensureUntabbable();\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.\n     * This makes the managed node focusable again and deletes all of the previously stored state.\n     */\n\n\n    _createClass(InertNode, [{\n      key: 'destructor',\n      value: function destructor() {\n        this._throwIfDestroyed();\n\n        if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n          var element = /** @type {!HTMLElement} */this._node;\n          if (this._savedTabIndex !== null) {\n            element.setAttribute('tabindex', this._savedTabIndex);\n          } else {\n            element.removeAttribute('tabindex');\n          }\n\n          // Use `delete` to restore native focus method.\n          if (this._overrodeFocusMethod) {\n            delete element.focus;\n          }\n        }\n\n        // See note in InertRoot.destructor for why we cast these nulls to ANY.\n        this._node = /** @type {?} */null;\n        this._inertRoots = /** @type {?} */null;\n        this._destroyed = true;\n      }\n\n      /**\n       * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n       * If the object has been destroyed, any attempt to access it will cause an exception.\n       */\n\n    }, {\n      key: '_throwIfDestroyed',\n\n\n      /**\n       * Throw if user tries to access destroyed InertNode.\n       */\n      value: function _throwIfDestroyed() {\n        if (this.destroyed) {\n          throw new Error('Trying to access destroyed InertNode');\n        }\n      }\n\n      /** @return {boolean} */\n\n    }, {\n      key: 'ensureUntabbable',\n\n\n      /** Save the existing tabindex value and make the node untabbable and unfocusable */\n      value: function ensureUntabbable() {\n        if (this.node.nodeType !== Node.ELEMENT_NODE) {\n          return;\n        }\n        var element = /** @type {!HTMLElement} */this.node;\n        if (matches.call(element, _focusableElementsString)) {\n          if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {\n            return;\n          }\n\n          if (element.hasAttribute('tabindex')) {\n            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n          }\n          element.setAttribute('tabindex', '-1');\n          if (element.nodeType === Node.ELEMENT_NODE) {\n            element.focus = function () {};\n            this._overrodeFocusMethod = true;\n          }\n        } else if (element.hasAttribute('tabindex')) {\n          this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n          element.removeAttribute('tabindex');\n        }\n      }\n\n      /**\n       * Add another inert root to this inert node's set of managing inert roots.\n       * @param {!InertRoot} inertRoot\n       */\n\n    }, {\n      key: 'addInertRoot',\n      value: function addInertRoot(inertRoot) {\n        this._throwIfDestroyed();\n        this._inertRoots.add(inertRoot);\n      }\n\n      /**\n       * Remove the given inert root from this inert node's set of managing inert roots.\n       * If the set of managing inert roots becomes empty, this node is no longer inert,\n       * so the object should be destroyed.\n       * @param {!InertRoot} inertRoot\n       */\n\n    }, {\n      key: 'removeInertRoot',\n      value: function removeInertRoot(inertRoot) {\n        this._throwIfDestroyed();\n        this._inertRoots['delete'](inertRoot);\n        if (this._inertRoots.size === 0) {\n          this.destructor();\n        }\n      }\n    }, {\n      key: 'destroyed',\n      get: function get() {\n        return (/** @type {!InertNode} */this._destroyed\n        );\n      }\n    }, {\n      key: 'hasSavedTabIndex',\n      get: function get() {\n        return this._savedTabIndex !== null;\n      }\n\n      /** @return {!Node} */\n\n    }, {\n      key: 'node',\n      get: function get() {\n        this._throwIfDestroyed();\n        return this._node;\n      }\n\n      /** @param {?number} tabIndex */\n\n    }, {\n      key: 'savedTabIndex',\n      set: function set(tabIndex) {\n        this._throwIfDestroyed();\n        this._savedTabIndex = tabIndex;\n      }\n\n      /** @return {?number} */\n      ,\n      get: function get() {\n        this._throwIfDestroyed();\n        return this._savedTabIndex;\n      }\n    }]);\n\n    return InertNode;\n  }();\n\n  /**\n   * InertManager is a per-document singleton object which manages all inert roots and nodes.\n   *\n   * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n   * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n   * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n   * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n   * is created for each such node, via the `_managedNodes` map.\n   */\n\n\n  var InertManager = function () {\n    /**\n     * @param {!Document} document\n     */\n    function InertManager(document) {\n      _classCallCheck(this, InertManager);\n\n      if (!document) {\n        throw new Error('Missing required argument; InertManager needs to wrap a document.');\n      }\n\n      /** @type {!Document} */\n      this._document = document;\n\n      /**\n       * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertNode>}\n       */\n      this._managedNodes = new Map();\n\n      /**\n       * All inert roots known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertRoot>}\n       */\n      this._inertRoots = new Map();\n\n      /**\n       * Observer for mutations on `document.body`.\n       * @type {!MutationObserver}\n       */\n      this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n      // Add inert style.\n      addInertStyle(document.head || document.body || document.documentElement);\n\n      // Wait for document to be loaded.\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n      } else {\n        this._onDocumentLoaded();\n      }\n    }\n\n    /**\n     * Set whether the given element should be an inert root or not.\n     * @param {!HTMLElement} root\n     * @param {boolean} inert\n     */\n\n\n    _createClass(InertManager, [{\n      key: 'setInert',\n      value: function setInert(root, inert) {\n        if (inert) {\n          if (this._inertRoots.has(root)) {\n            // element is already inert\n            return;\n          }\n\n          var inertRoot = new InertRoot(root, this);\n          root.setAttribute('inert', '');\n          this._inertRoots.set(root, inertRoot);\n          // If not contained in the document, it must be in a shadowRoot.\n          // Ensure inert styles are added there.\n          if (!this._document.body.contains(root)) {\n            var parent = root.parentNode;\n            while (parent) {\n              if (parent.nodeType === 11) {\n                addInertStyle(parent);\n              }\n              parent = parent.parentNode;\n            }\n          }\n        } else {\n          if (!this._inertRoots.has(root)) {\n            // element is already non-inert\n            return;\n          }\n\n          var _inertRoot = this._inertRoots.get(root);\n          _inertRoot.destructor();\n          this._inertRoots['delete'](root);\n          root.removeAttribute('inert');\n        }\n      }\n\n      /**\n       * Get the InertRoot object corresponding to the given inert root element, if any.\n       * @param {!Node} element\n       * @return {!InertRoot|undefined}\n       */\n\n    }, {\n      key: 'getInertRoot',\n      value: function getInertRoot(element) {\n        return this._inertRoots.get(element);\n      }\n\n      /**\n       * Register the given InertRoot as managing the given node.\n       * In the case where the node has a previously existing inert root, this inert root will\n       * be added to its set of inert roots.\n       * @param {!Node} node\n       * @param {!InertRoot} inertRoot\n       * @return {!InertNode} inertNode\n       */\n\n    }, {\n      key: 'register',\n      value: function register(node, inertRoot) {\n        var inertNode = this._managedNodes.get(node);\n        if (inertNode !== undefined) {\n          // node was already in an inert subtree\n          inertNode.addInertRoot(inertRoot);\n        } else {\n          inertNode = new InertNode(node, inertRoot);\n        }\n\n        this._managedNodes.set(node, inertNode);\n\n        return inertNode;\n      }\n\n      /**\n       * De-register the given InertRoot as managing the given inert node.\n       * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n       * node from the InertManager's set of managed nodes if it is destroyed.\n       * If the node is not currently managed, this is essentially a no-op.\n       * @param {!Node} node\n       * @param {!InertRoot} inertRoot\n       * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n       */\n\n    }, {\n      key: 'deregister',\n      value: function deregister(node, inertRoot) {\n        var inertNode = this._managedNodes.get(node);\n        if (!inertNode) {\n          return null;\n        }\n\n        inertNode.removeInertRoot(inertRoot);\n        if (inertNode.destroyed) {\n          this._managedNodes['delete'](node);\n        }\n\n        return inertNode;\n      }\n\n      /**\n       * Callback used when document has finished loading.\n       */\n\n    }, {\n      key: '_onDocumentLoaded',\n      value: function _onDocumentLoaded() {\n        // Find all inert roots in document and make them actually inert.\n        var inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n        inertElements.forEach(function (inertElement) {\n          this.setInert(inertElement, true);\n        }, this);\n\n        // Comment this out to use programmatic API only.\n        this._observer.observe(this._document.body || this._document.documentElement, { attributes: true, subtree: true, childList: true });\n      }\n\n      /**\n       * Callback used when mutation observer detects attribute changes.\n       * @param {!Array<!MutationRecord>} records\n       * @param {!MutationObserver} self\n       */\n\n    }, {\n      key: '_watchForInert',\n      value: function _watchForInert(records, self) {\n        var _this = this;\n        records.forEach(function (record) {\n          switch (record.type) {\n            case 'childList':\n              slice.call(record.addedNodes).forEach(function (node) {\n                if (node.nodeType !== Node.ELEMENT_NODE) {\n                  return;\n                }\n                var inertElements = slice.call(node.querySelectorAll('[inert]'));\n                if (matches.call(node, '[inert]')) {\n                  inertElements.unshift(node);\n                }\n                inertElements.forEach(function (inertElement) {\n                  this.setInert(inertElement, true);\n                }, _this);\n              }, _this);\n              break;\n            case 'attributes':\n              if (record.attributeName !== 'inert') {\n                return;\n              }\n              var target = /** @type {!HTMLElement} */record.target;\n              var inert = target.hasAttribute('inert');\n              _this.setInert(target, inert);\n              break;\n          }\n        }, this);\n      }\n    }]);\n\n    return InertManager;\n  }();\n\n  /**\n   * Recursively walk the composed tree from |node|.\n   * @param {!Node} node\n   * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,\n   *     before descending into child nodes.\n   * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n   */\n\n\n  function composedTreeWalk(node, callback, shadowRootAncestor) {\n    if (node.nodeType == Node.ELEMENT_NODE) {\n      var element = /** @type {!HTMLElement} */node;\n      if (callback) {\n        callback(element);\n      }\n\n      // Descend into node:\n      // If it has a ShadowRoot, ignore all child elements - these will be picked\n      // up by the <content> or <shadow> elements. Descend straight into the\n      // ShadowRoot.\n      var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;\n      if (shadowRoot) {\n        composedTreeWalk(shadowRoot, callback, shadowRoot);\n        return;\n      }\n\n      // If it is a <content> element, descend into distributed elements - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'content') {\n        var content = /** @type {!HTMLContentElement} */element;\n        // Verifies if ShadowDom v0 is supported.\n        var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\n        for (var i = 0; i < distributedNodes.length; i++) {\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n\n      // If it is a <slot> element, descend into assigned nodes - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'slot') {\n        var slot = /** @type {!HTMLSlotElement} */element;\n        // Verify if ShadowDom v1 is supported.\n        var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];\n        for (var _i = 0; _i < _distributedNodes.length; _i++) {\n          composedTreeWalk(_distributedNodes[_i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n    }\n\n    // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n    // element, nor a <shadow> element recurse normally.\n    var child = node.firstChild;\n    while (child != null) {\n      composedTreeWalk(child, callback, shadowRootAncestor);\n      child = child.nextSibling;\n    }\n  }\n\n  /**\n   * Adds a style element to the node containing the inert specific styles\n   * @param {!Node} node\n   */\n  function addInertStyle(node) {\n    if (node.querySelector('style#inert-style, link#inert-style')) {\n      return;\n    }\n    var style = document.createElement('style');\n    style.setAttribute('id', 'inert-style');\n    style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '  user-select: none;\\n' + '}\\n';\n    node.appendChild(style);\n  }\n\n  if (!HTMLElement.prototype.hasOwnProperty('inert')) {\n    /** @type {!InertManager} */\n    var inertManager = new InertManager(document);\n\n    Object.defineProperty(HTMLElement.prototype, 'inert', {\n      enumerable: true,\n      /** @this {!HTMLElement} */\n      get: function get() {\n        return this.hasAttribute('inert');\n      },\n      /** @this {!HTMLElement} */\n      set: function set(inert) {\n        inertManager.setInert(this, inert);\n      }\n    });\n  }\n})();\n"],"names":["_a","_b","_c","_blockingElements","_alreadyInertElements","_topElParents","_siblingsToRestore","_parentMO","_topChanged","_swapInertedSibling","_inertSiblings","_restoreInertedSiblings","_getParents","_getDistributedChildren","_isInertable","_handleMutations","BlockingElementsImpl","nullable","elems","element","i","top","newTop","toKeepInert","oldParents","newParents","toSkip","j","oldInert","newInert","siblingsToRestore","elements","siblings","sibling","parent","children","inertedSiblings","mo","parentToObserve","maybeShadyRoot","mutations","parents","mutation","target","idx","inertedChild","current","shadowRoot","result","nodes","slots","_createClass","defineProperties","props","descriptor","Constructor","protoProps","staticProps","_classCallCheck","instance","slice","matches","_focusableElementsString","InertRoot","rootElement","inertManager","inertNode","startNode","_this2","composedTreeWalk","node","activeElement","root","_this3","inertSubroot","savedInertNode","records","self","record","managedNode","ariaHidden","InertNode","inertRoot","tabIndex","InertManager","document","addInertStyle","inert","_inertRoot","inertElements","inertElement","_this","callback","shadowRootAncestor","content","distributedNodes","slot","_distributedNodes","_i","child","style"],"mappings":"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","x_google_ignoreList":[0,1]}